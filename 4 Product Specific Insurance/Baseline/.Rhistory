t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
t_D[n_A] <- next_dep(t, lambda)
}
#If there is a departure
else if (any(t_D < t_A) & any(t_D < t_C)) {
#Set time to time of next departure
t <- min(t_D)
#Subtract departure from system count
n_0 <- n_0 - 1
#Calculate next departure
t_D[which.min(t_D)] <- Inf
t_C[which.min(t_D)] <- Inf
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
#Checks if they are below the threshold
if ((c_0 - cost + rev) <= C) {
#If they are, add a 1 to the list
B <- c(B,1)
} else{
#If they are not, add a 0 to the list
B <- c(B,0)
}
}
B
#Count values of 1s, the function stores the 1s count at index 2
value_count <- table(B)
#Calculate P as described above
P <- value_count[2] / length(B)
#Output P
P
value_count <- as.data.frame(value_count) %>% rename("Outcome" = B, "Simulations" = Freq)
plot_2 <- ggplot(data = value_count, aes(x = Outcome, y = Simulations)) +
geom_bar(stat = 'identity', fill = "#00BFC4") +
scale_x_discrete(labels=c("0" = "Above Threshold", "1" = "Below Threshold"))
plot_2
library(ggplot2)
library(dplyr)
set.seed(1)
next_pois <- function(t, x) {
U <- runif(1)
return(t - (1/x) * log(U))
}
mu_t = function(t){
return(1/(t+12))
}
next_dep <- function(t, lambda) {
flag = 1
while(flag){
U1 <- runif(1)
t = t - (1/lambda) * log(U1)
U2 <- runif(1)
if (U2 <= mu_t(t)/lambda) {
T_s <- t
flag = 0
}
}
return (T_s)
}
new_month <- function(t, months) {
if (floor(t) %in% months) {
return(FALSE)
} else {
return(TRUE)
}
}
#Monthly poisson process parameter for arrivals
lambda <- 3
#Yearly poisson process parameter for claims
alpha <- 3.5
#Starting capital
c_0 <- 50000
#Capital floor
C <- 30000
#Fixed monthly fee
M <- 350
### Output Variables ################################
#We first define a list which records if the firm went below the threshold C.
B <- c()
### Main Loop ########################################
#We next define a for loop, so we run the simulation for 1000 iterations.
for (k in 1:1000) {
### Variables #################
#Start at time 0
t <- 0
#Number of arrivals by time t
n_A <- 0
#We run simulation for 12 months
total_t <- 12
### State variables ######################
#Number of customers currently in system
n_0 <- 0
#Defines our current cost accrued
cost <- 0
#Defines our current revenue generated
rev <- 0
#Describes what month we are currently in
months <- c(0)
### Event variables ######################
#Define time of next arrival from Poisson process
t_A <- next_pois(t, lambda)
#Define time of next departure
t_D <- c(Inf)
#Define list of next claims
t_C <- c(Inf)
### 12 Month Loop ########################
while(t <= total_t){
#Calculate whether we are in new month yet
if (new_month(t, months)) {
#If yes, then add monthly income to revenue
months <- c(months, floor(t))
rev <- rev + M*n_0
}
#If there is arrival
if ((all(t_A <= t_D)) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
t_D[n_A] <- next_dep(t, lambda)
}
#If there is a departure
else if (any(t_D < t_A) & any(t_D < t_C)) {
#Set time to time of next departure
t <- min(t_D)
#Subtract departure from system count
n_0 <- n_0 - 1
#Calculate next departure
t_D[which.min(t_D)] <- Inf
t_C[which.min(t_D)] <- Inf
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
#Checks if they are below the threshold
if ((c_0 - cost + rev) <= C) {
#If they are, add a 1 to the list
B <- c(B,1)
} else{
#If they are not, add a 0 to the list
B <- c(B,0)
}
}
B
#Count values of 1s, the function stores the 1s count at index 2
value_count <- table(B)
#Calculate P as described above
P <- value_count[2] / length(B)
#Output P
P
value_count <- as.data.frame(value_count) %>% rename("Outcome" = B, "Simulations" = Freq)
plot_3 <- ggplot(data = value_count, aes(x = Outcome, y = Simulations)) +
geom_bar(stat = 'identity', fill = "#00BFC4") +
scale_x_discrete(labels=c("0" = "Above Threshold", "1" = "Below Threshold"))
plot_3
plot_3 <- ggplot(data = value_count, aes(x = Outcome, y = Simulations)) +
geom_bar(stat = 'identity', fill = "#00BFC4") +
scale_x_discrete(labels=c("0" = "Above Threshold", "1" = "Below Threshold"))
plot_3
library(ggplot2)
library(dplyr)
set.seed(1)
next_pois <- function(t, x) {
U <- runif(1)
return(t - (1/x) * log(U))
}
mu_t = function(t){
return(1/(t+12))
}
next_dep <- function(t, lambda) {
flag = 1
while(flag){
U1 <- runif(1)
t = t - (1/lambda) * log(U1)
U2 <- runif(1)
if (U2 <= mu_t(t)/lambda) {
T_s <- t
flag = 0
}
}
return (T_s)
}
new_month <- function(t, months) {
if (floor(t) %in% months) {
return(FALSE)
} else {
return(TRUE)
}
}
#Monthly poisson process parameter for arrivals
lambda <- 3
#Yearly poisson process parameter for claims
alpha <- 3.5
#Starting capital
c_0 <- 50000
#Capital floor
C <- 30000
#Fixed monthly fee
M <- 300
### Output Variables ################################
#We first define a list which records if the firm went below the threshold C.
B <- c()
### Main Loop ########################################
#We next define a for loop, so we run the simulation for 1000 iterations.
for (k in 1:1000) {
### Variables #################
#Start at time 0
t <- 0
#Number of arrivals by time t
n_A <- 0
#We run simulation for 12 months
total_t <- 12
### State variables ######################
#Number of customers currently in system
n_0 <- 0
#Defines our current cost accrued
cost <- 0
#Defines our current revenue generated
rev <- 0
#Describes what month we are currently in
months <- c(0)
### Event variables ######################
#Define time of next arrival from Poisson process
t_A <- next_pois(t, lambda)
#Define time of next departure
t_D <- c(Inf)
#Define list of next claims
t_C <- c(Inf)
### 12 Month Loop ########################
while(t <= total_t){
#Calculate whether we are in new month yet
if (new_month(t, months)) {
#If yes, then add monthly income to revenue
months <- c(months, floor(t))
rev <- rev + M*n_0
}
#If there is arrival
if ((all(t_A <= t_D)) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
t_D[n_A] <- next_dep(t, lambda)
}
#If there is a departure
else if (any(t_D < t_A) & any(t_D < t_C)) {
#Set time to time of next departure
t <- min(t_D)
#Subtract departure from system count
n_0 <- n_0 - 1
#Calculate next departure
t_D[which.min(t_D)] <- Inf
t_C[which.min(t_D)] <- Inf
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
#Checks if they are below the threshold
if ((c_0 - cost + rev) <= C) {
#If they are, add a 1 to the list
B <- c(B,1)
} else{
#If they are not, add a 0 to the list
B <- c(B,0)
}
}
B
#Count values of 1s, the function stores the 1s count at index 2
value_count <- table(B)
#Calculate P as described above
P <- value_count[2] / length(B)
#Output P
P
library(ggplot2)
library(dplyr)
set.seed(1)
next_pois <- function(t, x) {
U <- runif(1)
return(t - (1/x) * log(U))
}
mu_t = function(t){
return(1/(t+12))
}
next_dep <- function(t, lambda) {
flag = 1
while(flag){
U1 <- runif(1)
t = t - (1/lambda) * log(U1)
U2 <- runif(1)
if (U2 <= mu_t(t)/lambda) {
T_s <- t
flag = 0
}
}
return (T_s)
}
new_month <- function(t, months) {
if (floor(t) %in% months) {
return(FALSE)
} else {
return(TRUE)
}
}
gen_sample_mean_var = function(n, Z, Z_bar, S_sq){
Z_bar_new = Z_bar + (Z-Z_bar)/(n+1)
S_sq_new = (1-(1/n))*S_sq + (n+1)*(Z_bar_new - Z_bar)^2
return(c(Z_bar_new,S_sq_new))
}
#Monthly poisson process parameter for arrivals
lambda <- 3
#Yearly poisson process parameter for claims
alpha <- 3.5
#Starting capital
c_0 <- 50000
#Capital floor
C <- 30000
#Fixed monthly fee
M <- 300
### Output Variables ################################
k_90 <- 0
C_12_90 <- 0
S_sq_90 <- 0
capital_list <- c()
### Other Initialisations ############################
#We need to initialise the first variance, that being 0
S_sq <- 0
#And the start of the counter
k <- 1
### Main Loop ########################################
#We next define a while loop, so we run the simulation for 3000 iterations.
while (k < 3000) {
### Starting Parameters #################
#Start at time 0
t <- 0
#Number of arrivals by time t
n_A <- 0
#We run simulation for 12 months
total_t <- 12
### State variables ######################
#Number of customers currently in system
n_0 <- 0
#Defines our current cost accrued
cost <- 0
#Defines our current revenue generated
rev <- 0
#Describes what month we are currently in
months <- c()
### Event variables ######################
#Define time of next arrival from Poisson process
t_A <- next_pois(t, lambda)
#Define time of next departure
t_D <- c(Inf)
#Define list of next claims
t_C <- c(Inf)
### 12 Month Loop ########################
while(t <= total_t){
#Here we check we have not entered a new month yet
if (new_month(t, months)) {
months <- c(months, floor(t))
rev <- rev + M*n_0
}
#If there is arrival
if ((all(t_A <= t_D)) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
t_D[n_A] <- next_dep(t, lambda)
}
#If there is a departure
else if (any(t_D < t_A) & any(t_D < t_C)) {
#Set time to time of next departure
t <- min(t_D)
#Subtract departure from system count
n_0 <- n_0 - 1
#Calculate next departure
t_D[which.min(t_D)] <- Inf
t_C[which.min(t_D)] <- Inf
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
### Estimation Section ###
#We first our simulated capital at the end of 12 months
C_12 <- (c_0 - cost + rev)
capital_list <- c(capital_list, C_12)
#If it is the first iteration, we set the sample mean to our first estimate
if (k == 1){
C_12_bar <- C_12
}
#We now generate our next sample mean and variance
out <- gen_sample_mean_var(k, C_12, C_12_bar, S_sq)
#We then retrieve these values
C_12_bar <- out[1]
S_sq <- out[2]
#We then print this to assess convergence
print(sqrt(S_sq/k))
#We then check we have satisfied our requirements for confidence interval, the last condition      ensures we record only the first time we satisfy this requirement
if (sqrt(S_sq/k) < (500/1.645) & k != 1 & (C_12_90+k_90+S_sq_90 == 0)){
#We then collect our output values
C_12_90 <- C_12_bar
k_90 <- k
S_sq_90 <- S_sq
}
#We then add to counter
k <- k+1
}
C_12_90
k_90
S_sq_90
S_90 <- sqrt(S_sq_90/k_90)
S_90
freq <- data.frame(list(capital_list))
plot_1 <- ggplot(freq, aes(x = capital_list)) +
geom_histogram(bins = 70, fill = "#00BFC4") +
xlab("Capital Stock at 12 Months") +
ylab("Simulations") +
geom_vline(xintercept=30000)
plot_1
