}
#If there is a departure
else if ((t_D < t_A) & any((t_D < t_C))) {
#Set time to time of next departure
t <- t_D
#Subtract departure from system count
n_0 <- n_0 - 1
#Add departure to departure count
n_D <- n_D + 1
#Calculate next departure
t_D <- next_dep(t, lambda)
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Add one claim to claim count
n_C <- n_C+1
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
if ((c_0 - cost) <= C) {
S <- c(S,1)
} else{
S <- c(S,0)
}
t_C
any(t_C < t_A)
n_0 <- 1
c_0 <- 50000
C <- 30000
t <- 0
t_A <- 0
t_D <- Inf
t_C <- c(Inf)
total_t <- 12
n_A <- 1
n_D <- 0
n_C <- 0
cost <- 0
lambda <- 3
alpha <- 3.5
t <- next_pois(t, lambda)
while(t<=total_t){
#If there is arrival
if ((t_A <= t_D) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
if (n_A == 1) {
t_D <- next_dep(t, lambda)
}
}
#If there is a departure
else if ((t_D < t_A) & all((t_D < t_C))) {
#Set time to time of next departure
t <- t_D
#Subtract departure from system count
n_0 <- n_0 - 1
#Add departure to departure count
n_D <- n_D + 1
#Calculate next departure
t_D <- next_dep(t, lambda)
}
#If there is a claim
else if (all((t_C < t_A)) & all((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Add one claim to claim count
n_C <- n_C+1
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
n_0 <- 1
c_0 <- 50000
C <- 30000
t <- 0
t_A <- 0
t_D <- Inf
t_C <- c(Inf)
total_t <- 12
n_A <- 1
n_D <- 0
n_C <- 0
cost <- 0
lambda <- 3
alpha <- 3.5
t <- next_pois(t, lambda)
while(t<=total_t){
#If there is arrival
if ((t_A <= t_D) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
if (n_A == 1) {
t_D <- next_dep(t, lambda)
}
}
#If there is a departure
else if ((t_D < t_A) & all((t_D < t_C))) {
#Set time to time of next departure
t <- t_D
#Subtract departure from system count
n_0 <- n_0 - 1
#Add departure to departure count
n_D <- n_D + 1
#Calculate next departure
t_D <- next_dep(t, lambda)
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Add one claim to claim count
n_C <- n_C+1
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
if ((c_0 - cost) <= C) {
S <- c(S,1)
} else{
S <- c(S,0)
}
n_0 <- 1
c_0 <- 50000
C <- 30000
t <- 0
t_A <- 0
t_D <- Inf
t_C <- c(Inf)
total_t <- 12
n_A <- 1
n_D <- 0
n_C <- 0
cost <- 0
lambda <- 3
alpha <- 3.5
t <- next_pois(t, lambda)
while(t<=total_t){
#If there is arrival
if ((t_A <= t_D) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
if (n_A == 1) {
t_D <- next_dep(t, lambda)
}
}
#If there is a departure
else if ((t_D < t_A) & all((t_D < t_C))) {
#Set time to time of next departure
t <- t_D
#Subtract departure from system count
n_0 <- n_0 - 1
#Add departure to departure count
n_D <- n_D + 1
#Calculate next departure
t_D <- next_dep(t, lambda)
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Add one claim to claim count
n_C <- n_C+1
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
if ((c_0 - cost) <= C) {
S <- c(S,1)
} else{
S <- c(S,0)
}
set.seed(1)
next_pois <- function(t, x) {
U <- runif(1)
return(t - (1/x) * log(U))
}
mu_t = function(t){
return(1/(t+12))
}
next_dep <- function(t, lambda) {
flag = 1
while(flag){
U1 <- runif(1)
t = t - (1/lambda) * log(U1)
U2 <- runif(1)
if (U2 <= mu_t(t)/lambda) {
T_s <- t
flag = 0
}
}
return (T_s)
}
n_0 <- 0
c_0 <- 50000
C <- 30000
t <- 0
t_A <- 0
t_D <- Inf
t_C <- Inf
total_t <- 12
n_A <- 1
n_D <- 0
n_C <- 0
cost <- 0
lambda <- 3
alpha <- 3.5
S <- c()
n_0 <- 1
c_0 <- 50000
C <- 30000
t <- 0
t_A <- 0
t_D <- Inf
t_C <- c(Inf)
total_t <- 12
n_A <- 1
n_D <- 0
n_C <- 0
cost <- 0
lambda <- 3
alpha <- 3.5
t <- next_pois(t, lambda)
while(t<=total_t){
#If there is arrival
if ((t_A <= t_D) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
if (n_A == 1) {
t_D <- next_dep(t, lambda)
}
}
#If there is a departure
else if ((t_D < t_A) & all((t_D < t_C))) {
#Set time to time of next departure
t <- t_D
#Subtract departure from system count
n_0 <- n_0 - 1
#Add departure to departure count
n_D <- n_D + 1
#Calculate next departure
t_D <- next_dep(t, lambda)
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Add one claim to claim count
n_C <- n_C+1
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
if ((c_0 - cost) <= C) {
S <- c(S,1)
} else{
S <- c(S,0)
}
S <- c()
for (k in 1:1000) {
n_0 <- 1
c_0 <- 50000
C <- 30000
t <- 0
t_A <- 0
t_D <- Inf
t_C <- c(Inf)
total_t <- 12
n_A <- 1
n_D <- 0
n_C <- 0
cost <- 0
lambda <- 3
alpha <- 3.5
t <- next_pois(t, lambda)
while(t<=total_t){
#If there is arrival
if ((t_A <= t_D) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
if (n_A == 1) {
t_D <- next_dep(t, lambda)
}
}
#If there is a departure
else if ((t_D < t_A) & all((t_D < t_C))) {
#Set time to time of next departure
t <- t_D
#Subtract departure from system count
n_0 <- n_0 - 1
#Add departure to departure count
n_D <- n_D + 1
#Calculate next departure
t_D <- next_dep(t, lambda)
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Add one claim to claim count
n_C <- n_C+1
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
if ((c_0 - cost) <= C) {
S <- c(S,1)
} else{
S <- c(S,0)
}
}
S
t_C
rev <- rev + M*n_0
S <- c()
for (k in 1:1000) {
n_0 <- 1
c_0 <- 50000
C <- 30000
M <- 300
t <- 0
t_A <- 0
t_D <- Inf
t_C <- c(Inf)
total_t <- 12
n_A <- 1
n_D <- 0
n_C <- 0
cost <- 0
rev <- 0
lambda <- 3
alpha <- 3.5
t <- next_pois(t, lambda)
while(t<=total_t){
#Update revenue
rev <- rev + M*n_0
#If there is arrival
if ((t_A <= t_D) & (all(t_A <= t_C))){
#Set time to time of next arrival
t <- t_A
#Add arrival to number of arrivals
n_A <- n_A + 1
#Count arrival in system count
n_0 <- n_0 + 1
#Calculate next arrival time
t_A <- next_pois(t, lambda)
#On first iteration, we now calculate time to next claim
t_C[n_A] <- next_pois(t, (alpha/12))
#On first iteration, we need to calculate next departure time
if (n_A == 1) {
t_D <- next_dep(t, lambda)
}
}
#If there is a departure
else if ((t_D < t_A) & all((t_D < t_C))) {
#Set time to time of next departure
t <- t_D
#Subtract departure from system count
n_0 <- n_0 - 1
#Add departure to departure count
n_D <- n_D + 1
#Calculate next departure
t_D <- next_dep(t, lambda)
}
#If there is a claim
else if (any((t_C < t_A)) & any((t_C < t_D))){
#Set time to time of next claim
t <- min(t_C)
#Add one claim to claim count
n_C <- n_C+1
#Generate next claim time
t_C[which.min(t_C)] <- next_pois(t, (alpha/12))
##Calculate pay-out
#Generate random uniform variable
pay_out_p <- runif(1)
#If the variable is less than 0.6, then execute code
if (pay_out_p <= 0.6){
#Calculate random variable, multiply by 10, and obtain its upper integer
X <- ceiling(10*runif(1))
#Calculate pay-out based on this
pay_out <- 300*X + 500
#Add it to the running total
cost <- cost + pay_out
}
}
}
if ((c_0 - cost + rev) <= C) {
S <- c(S,1)
} else{
S <- c(S,0)
}
}
S
